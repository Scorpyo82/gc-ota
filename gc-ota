#!/system/bin/sh


    #######################################
    ##  Script realizado por Scorpyo82   ##
    ##   Para la aplicación de ajustes   ##
    ##  de la CustomROM GingerCerecilla  ##
    #######################################

#    gc-ota es un script que se encarga de
#    comprobar las actualizaciones que pueda
#    haber en el repositorio oficial de GingerCerecilla
#
#    También descargará las actualizaciones y prepara
#    todo lo necesario para reiniciar e instalarla
#
#    Miguel Ponce Torres
#    Copyright (C) <2014> <Miguel Ponce Torres>
#    mail: miguelponcetorres@gmail.com
#
#    Aún así, no es totalmente necesario tener instalado
#    la app "Ajustes especiales GC" ya que este Script
#    Puede ser llamado mediante argumentos desde línea
#    de comandos
#
#    Este Script y sus métodos están protegidos bajo licencia GNU GPL
#
#    This program is free software: you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation, either version 3 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program.  If not, see <http://www.gnu.org/licenses/>.
#
#
#    Este script está diseñado para que funcione bajo sistemas
#    rooteados y con busybox instalado.


#VARIABLES

# Esta variable define la versión del Script actual:
VERSION="1.0"

# Variable que define el archivo en el que se debe de escribir los datos recogidos del repositorio.
PATH_XML="/data/data/es.pccitos.gcsettings/shared_prefs/OtaInfo.xml"

# Ruta en la que se encuentra actualmente este Script.
PATH_GCOTA="/system/xbin/gc-ota"

# Nombre del archivo que se escribirá en init.d para activar CRON con las búsquedas programadas.
PATH_FILE_INIT_D="/system/etc/init.d/08gc-ota"

# Esta variable define el lugar donde se almacena el log generado, tenga en cuenta de que el script está preparado para escribir
# en la partición /system si usté quiere generar el log en algún otro lugar deve de asegurarse de tener permisos de escritura.
LOG="/system/gc-ota_$VERSION.log"

# Variable que recoge el nombre en clave que debe tener el archivo que hace reaccionar al recovery selectivo para usar el
# Recovery viejo en lugar del nuevo, si ustéd está usando un kernel que no tenga esta opción pero que sea compatible con 
# los archivos "command" para autoinstalar los zip no deve de preocuparse en cambiar esta opción.
KEY_RECOVERY_OLD="/cache/recovery/load-recovery-old"

# Ruta raiz para los trabajos de la aplicación
PATH_HOME="/sdcard/GC-OTA/"

# Ruta donde se descargará la lista de actualizaciones
PATH_REPO_DOWNLOAD="/sdcard/GC-OTA/repo/"

# Ruta donde se descargarán los achivos de actualizaciones
PATH_FILES_DOWNLOAD="/sdcard/GC-OTA/files"

# Esta variable recogera de su build.prop el valor de la versión de la ROM actual 
VERSION_GINGER=$(getprop gingercerecilla.version)

# Esta variable recogera de su build.prop el valor del último update instalado o número de actualización realizada
UPDATE_ACTUAL=$(getprop gingercerecilla.update)

# Esta variable recogera de su build.prop el valor de la dirección hasta el repositorio en el que se descargará la información OTA
URL_REPO=$(getprop gingercerecilla.url.repo)

# Variable para el archivo de bloqueo que impedirá que la aplicación se ejecute dos veces al mismo tiempo.
# El destino elegijo es recomendable no cambiarlo, pues si la aplicación se cuelga, el archivo de bloqueo en este lugar se borrará
# trás un reinicio, con lo que podrá seguir usando despues de este el Script
LOCKFILE=/cache/recovery/gc-ota.lock

## FUNCIONES:

function SALIR(){
## Se borra el archivo de bloqueo y se monta system como solo lectura
rm $LOCKFILE
exit 1
}

function CHECK_RUN(){
## Función que comprueba si existe el archivo de bloqueo
## para que la aplicación no se ejecute dos veces

	echo ""
	if [ ! -e $LOCKFILE ]; then
		# Si no existe el archivo de bloqueo se crea
		# uno nuevo y se continua con la ejecución
		touch $LOCKFILE
	else
		#Mensaje para comunicar que aún se están ejecutando tareas
		echo "El archivo de bloqueo de gc-ota aún exite"
		echo "¿Está la aplicación en uso?"
		exit
	fi

}

function VAR_CONTROL(){
## Función para controlar que no haya ni una sola variable vacía de las importantes

	if [ -z $VERSION_GINGER ] || [ -z $UPDATE_ACTUAL ] || [ -z $URL_REPO ]
	then
		echo "Alguna de las variables en /system/build.prop no están definidas adecuadamente."
		SALIR
	else
		echo "Datos de versión actual obtenidos con exito"
		return 0
	fi
}


function CHECK_NET(){
## Función que comprueba el acceso a internet.

	echo "Comprobado el acceso al servidor web..."
	ping -c 1 www.pc-citos.es
	if [ $? == "0" ]
	then
		echo "Disponibilidad del servidor web comprobado y correcto"
		return 0
	else
		echo "Problema con el acceso al servidor web"
		SALIR
	fi
}

function CHECK_PATH_SD(){
## Función que comprueba si existe la extructura adecuada dentro de la SD para copiar los archivos.
	
	if [ ! -e $PATH_HOME ] || [ ! -e $PATH_FILES_DOWNLOAD ] || [ ! -e $PATH_REPO_DOWNLOAD ]
	then
		echo "Creando direcotrios necesarios en tarjeta SD..."
		mkdir -p $PATH_HOME $PATH_REPO_DOWNLOAD $PATH_FILES_DOWNLOAD
		echo "Directorios creados."
	else
		echo "Directorios en tarjeta SD detectados."
	fi
}

function CHECK_PATH_XML(){
## Función que comprueba si existe la ruta hasta llegar donde se deben de copiar los archivos XML.
	
	if [ ! -e /data/data/es.pccitos.gcsettings/shared_prefs ]
	then
		echo "La ruta para escribir los xml no existe."
		echo "Esto puede suceder por no tener la app correcta instalada"
		echo "O por no haberla utilizado nunca"
		SALIR
	else
		echo "Ruta para copiar los archivos XML detectados."
		echo ""
	fi
}

function DOWNLOAD_REPO(){
## Función que actualiza el archivo de repositorio con las actualizaciones publicadas en el server
	CHECK_PATH_SD
	CHECK_NET

	if [ -e "$PATH_REPO_DOWNLOAD/updates" ]
	then
		rm  $PATH_REPO_DOWNLOAD/updates
	fi
	wget $URL_REPO -P $PATH_REPO_DOWNLOAD
}


function SEARH_UPDATE(){
## Función que compara las versión actual del sistema, y la actualización corriente para buscar y seleccionar la actualización justo por encima.

	if [ -e $PATH_REPO_DOWNLOAD/updates ]
	then
		# Generamos un archivo temporal limpio (sin líneas vacías ni títulos de columnas) del archivo de repo.
		sed '1d' $PATH_REPO_DOWNLOAD/updates | sed '/^$/d' | sed '/./!d' > $PATH_REPO_DOWNLOAD/updates_temp

		# Buscaremos línea a línea
		while read line
		do
			# Si en esta línea se encuentra la misma versión en la columna 1 y una actualización un número mayor en la columna 2 entonces
			# se procede a anotar la dirección en la que está el paquete, su md5 y demás.
			VERSION_ON_REPO=$(echo $line | awk '{print $1}')
			UPDATE_ON_REPO=$(echo $line | awk '{print $2}')
			if [ $VERSION_ON_REPO == $VERSION_GINGER ] && [ $UPDATE_ON_REPO -gt $UPDATE_ACTUAL ]
			then
				MD5SUM_ZIP_REPO=$(echo $line | awk '{print $3}')
				LINK_UPDATE=$(echo $line | awk '{print $4}')
				CAMBIOS=$(echo $line | awk '{print $5}' | sed 's/_/ /g')
	
				echo "Se ha encontrado una actualización para la versión que está utilizando:"
				echo "Actualización nº $UPDATE_ON_REPO para la versión $UPDATE_ACTUAL"
				echo "Cambios:"
				echo $CAMBIOS
				break
				return 0
			fi

		echo "No se han encontrado actualizaciones, inténtelo más adelante"

		done < $PATH_REPO_DOWNLOAD/updates_temp

	else
		echo "Actualmente no hay ningún fichero de repositorio descargado..."
		echo "Use [gc-ota --update] para descargarlo desde el servidor web e inténtelo de nuevo"
	fi
}

function PREPARE_REBOOT(){
## Función que prepara todo lo necesario para actualizar el sistema con el nuevo update.zip

	#Fijando el nombre del paquete:
	UPDATEZIP="GC_v"$VERSION_GINGER"_Update_"$UPDATE_ON_REPO".zip"
	#Descargando paquete
	wget $LINK_UPDATE -O $PATH_FILES_DOWNLOAD/$UPDATEZIP
	if [ $? != 0 ]
	then
		echo "Ocurrión un error al descargar el archivo..."
		echo "Abortado"
		SALIR
	else
		echo "Archivo descargado con exito"
	fi
	
	#Obteniendo y comparando md5
	MD5SUM_ZIP=$(md5sum $PATH_FILES_DOWNLOAD/$UPDATEZIP | awk '{print $1}')
	if [ $MD5SUM_ZIP != $MD5SUM_ZIP_REPO ]
	then
		echo "La suma de verificación del archivo descargado no coincide con la que se esperaba"
		echo "¿¿Archivo corrupto??"
		return 1
	else
		echo "Suma de verificación exitosa"
	fi
	
	#Escribiendo archivo command con las ordenes de instalación:
	echo "--update_package="$PATH_FILES_DOWNLOAD/$UPDATEZIP > /cache/recovery/command

	#Escribiendo el archivo clave para que el sistema de encendido selectivo use el viejo binario de recovery 
	touch $KEY_RECOVERY_OLD

	echo "El sistema está listo para reiniciar en modo recovery y actualizarse de forma automática"
	echo "Use [reboot recovery] para reiniciar en modo recovery"

}

function CHANGES_TO_XML(){
## Función que genera un informe con los cambios encontrados para que sea leido por la app escogida

	CHECK_PATH_XML #Se llama a esta función para saber si es posible llegar hasta la ruta donde se deben de copiar los XML

	#Fijando el nombre del paquete a instalar:
	UPDATEZIP="GC_v"$VERSION_GINGER"_Update_"$UPDATE_ON_REPO".zip"

echo "Escribiendo un informe para que sea leido por la app..."

echo "<?xml version='1.0' encoding='utf-8' standalone='yes' ?>" > $PATH_XML
echo '<map>
<boolean name="preparado" value="true" />
<string name="version_rom_actual">'$VERSION_GINGER'</string>
<string name="update_ota">'$UPDATE_ON_REPO'</string>
<string name="ota_changes">'$CAMBIOS'</string>
<string name="update_package">'$UPDATEZIP'</string>
</map>
' >> $PATH_XML
echo "Hecho!"

	# Seteando permisos:
	PROPIETARIO=$(ls -dl $PATH_XML | awk '{print $3}')
	chown $PROPIETARIO:$PROPIETARIO $PATH_XML
	chmod 775 $PATH_XML

}

function HELP(){
## Función que muestra la ahuda del Script

	echo ""
	echo "	gc-ota Version $VERSION"
	echo '
    Modo de empleo: gc-ota [Opción]

    --app              Ejecuta los trabajos por defecto para usar la app "Ajustes Especiales GC".
    --check            Busca y muestra la información usando el último repo descargado
    --update           Actualiza el repositorio, muestra información, pero no actualiza el sistema
    --upgrade          Actualiza el sistema con la versión superior que esté disponible en el servidor
    --version          Muestra la versión de gc-settings
    --help             Muestra esta ayuda

    Desarrollado por <Miguel Ponce Torres> bajo GNU GPL <http://www.gnu.org/licenses/>
    MAIL: miguelponcetorres@gmail.com
'

}

## Gestión de argumentos

CHECK_RUN


case $1 in

	--app) #Descarga información del repositorio, comprueba versiones, crea el informe y lanza la app para instalar
		VAR_CONTROL #Siempre comprobar que las variables se han podido leer con exito
		SEARCH_UPDATE | tee $LOG
		DOWNLOAD_REPO | tee -a $LOG
		CHANGES_TO_XML | tee -a $LOG
		# Comando para abrir el OtaInfo
		am start -a android.intent.action.MAIN -n es.pccitos.gcsettings/.OtaInfo
	;;

	--check) #Busca información en el último repo descargado
		echo "Buscando la última información sobre el repositorio actual..."
		echo ""
		VAR_CONTROL #Siempre comprobar que las variables se han podido leer con exito
		SEARH_UPDATE

	;;

	--update) #Actualiza el repositorio, muestra información, pero no actualiza el sistema
		VAR_CONTROL #Siempre comprobar que las variables se han podido leer con exito
		DOWNLOAD_REPO
	;;
	
	--upgrade) # Actualiza el sistema con la versión superior encontrada
		VAR_CONTROL #Siempre comprobar que las variables se han podido leer con exito
		DOWNLOAD_REPO
		SEARH_UPDATE
		PREPARE_REBOOT
	;;

	--version)
		echo "	gc-ota Version $VERSION"
	;;

	--help)
		HELP
	;;

	*)
		echo "Comando no reconocido"
		sleep 1
		HELP
esac

SALIR
